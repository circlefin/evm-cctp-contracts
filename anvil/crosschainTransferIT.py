from typing import List, Dict
from web3 import Web3
import solcx
import unittest
import time

# All addresses are automatically generated by anvil at startup
addresses = {
    "attester": Web3.toChecksumAddress("0xbcd4042de499d14e55001ccbb24a551f3b954096"),
    "eth_usdc_master_minter": Web3.toChecksumAddress("0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266"),
    "eth_message_transmitter_deployer": Web3.toChecksumAddress("0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc"),
    "eth_token_messenger_deployer": Web3.toChecksumAddress("0x90f79bf6eb2c4f870365e785982e1f101e93b906"),
    "eth_token_minter_deployer": Web3.toChecksumAddress("0x15d34aaf54267db7d7c367839aaf71a00a2c6a65"),
    "eth_token_messenger_user": Web3.toChecksumAddress("0x23618e81e3f5cdf7f54c3d65f7fbc0abf5b21e8f"),
    "eth_token_controller": Web3.toChecksumAddress("0x71be63f3384f5fb98995898a86b02fb2426c5788"),
    "avax_usdc_master_minter": Web3.toChecksumAddress("0x70997970c51812dc3a010c7d01b50e0d17dc79c8"),
    "avax_message_transmitter_deployer": Web3.toChecksumAddress("0x9965507d1a55bcc2695c58ba16fb37d819b0a4dc"),
    "avax_token_messenger_deployer": Web3.toChecksumAddress("0x976ea74026e726554db657fa54763abd0c3a0aa9"),
    "avax_token_minter_deployer": Web3.toChecksumAddress("0x14dc79964da2c08b23698b3d3cc7ca32193d9955"),
    "avax_token_messenger_user": Web3.toChecksumAddress("0xa0ee7a142d267c1f36714e4a8f75612f20a79720"),
    "avax_token_controller": Web3.toChecksumAddress("0xfabb0ac9d68b0b445fb7357272ff202c5651694a"),
}

# All keys correspond with the addresses generated by anvil at startup
keys = {
    "attester": "0xf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897",
    "eth_usdc_master_minter": "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    "eth_message_transmitter_deployer": "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a",
    "eth_token_messenger_deployer": "0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6",
    "eth_token_minter_deployer": "0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a",
    "eth_token_messenger_user": "0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97",
    "eth_token_controller": "0x701b615bbdfb9de65240bc28bd21bbc0d996645a3dd57e7b12bc2bdf6f192c82",
    "avax_usdc_master_minter": "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
    "avax_message_transmitter_deployer": "0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba",
    "avax_token_messenger_deployer": "0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e",
    "avax_token_minter_deployer": "0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356",
    "avax_token_messenger_user": "0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6",
    "avax_token_controller": "0xa267530f49f8280200edf313ee7af6b827f2a8bce2897751d06a843f644967b1",
}

# Miscellaneous fixed values for contract deployment and configuration 
eth_domain = 0
avax_domain = 1
max_message_body_size = 8192
version = 0
message_body_version = 0
minter_allowance = 1000
mint_amount = 100
max_burn_message_amount = 1000000

def compile_source_file(file_path: str, contract_name: str, version: str = '0.7.6') -> Dict:
    """
    Takes in file path to a Solidity contract, contract name, and optional version params
    and returns a dictionary representing the compiled contract.
    """
    solcx.install_solc(version)
    solcx.set_solc_version(version)
    return solcx.compile_files(
        [file_path],
        output_values = ["abi", "bin"],
        import_remappings = {
            "@memview-sol/": "lib/memview-sol/",
            "@openzeppelin/": "lib/openzeppelin-contracts/",
            "ds-test/": "lib/ds-test/src/",
            "forge-std/": "lib/forge-std/src/"
        },
        allow_paths = ["."]
    )[f'{file_path}:{contract_name}']

class TestTokenMessengerWithUSDC(unittest.TestCase):
    def deploy_contract_from_source(
        self, 
        file_path: str, 
        contract_name: str, 
        version: str = '0.7.6', 
        libraries: Dict = {},
        constructor_args: List = [],
        caller = ""
    ):
        """
        Takes in a Solidity contract file path, contract name and optional Solidity 
        compiler version, dictionary of libraries to link, arguments for contract
        constructor, and caller address to compile, deploy, and construct a Solidity 
        contract. Returns a web3 contract object representing the deployed contract.
        """

        # Compile
        contract_interface = compile_source_file(file_path, contract_name, version)

        # Deploy
        if caller:
            unsigned_tx = self.w3.eth.contract(
                abi=contract_interface['abi'],
                bytecode=solcx.link_code(contract_interface['bin'], libraries)
            ).constructor(*constructor_args).build_transaction({
                'nonce': self.w3.eth.get_transaction_count(addresses[caller]),
                'from': addresses[caller]
            })
            
            signed_tx = self.w3.eth.account.sign_transaction(unsigned_tx, keys[caller])
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        else:
            tx_hash = self.w3.eth.contract(
                abi=contract_interface['abi'],
                bytecode=solcx.link_code(contract_interface['bin'], libraries)
            ).constructor(*constructor_args).transact()

        self.confirm_transaction(tx_hash)

        # Retrieve address and deployed contract
        address = self.w3.eth.get_transaction_receipt(tx_hash)['contractAddress']
        return self.w3.eth.contract(
            address=address,
            abi=contract_interface['abi']
        )

    def send_transaction(self, function_call, caller: str): 
        """
        Takes in an initialized function call and a designated caller and builds,
        signs, and sends the transaction. Verifies the transaction was received.
        """
        unsigned_tx = function_call.build_transaction({
            'nonce': self.w3.eth.get_transaction_count(addresses[caller]),
            'from': addresses[caller]
        })
        signed_tx = self.w3.eth.account.sign_transaction(unsigned_tx, keys[caller])
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        self.confirm_transaction(tx_hash)

    def verify_balances(self, expected_eth_usdc_balance, expected_avax_usdc_balance):
        """
        Verifies that the USDC balances at the test eth_token_messenger_user and avax_token_messenger_user
        accounts matches the input expected values.
        """
        assert(self.eth_usdc.functions.balanceOf(addresses["eth_token_messenger_user"]).call() == expected_eth_usdc_balance)
        assert(self.avax_usdc.functions.balanceOf(addresses["avax_token_messenger_user"]).call() == expected_avax_usdc_balance)

    def to_32byte_hex(self, address):
        """
        Converts a hex address to its zero-padded 32-byte representation.
        """
        return Web3.toHex(Web3.toBytes(hexstr=address).rjust(32, b'\0'))

    def confirm_transaction(self, tx_hash, timeout=30):
        """
        Waits until transaction receipt associated with tx_hash confirms completion.
        """
        counter = 0
        while counter < timeout:
            try:
                if self.w3.eth.get_transaction_receipt(tx_hash).status == 1:
                    return
            except:
                pass
            counter += 1
            time.sleep(1)
        
        raise RuntimeError(f"Transaction with hash {tx_hash} did not complete within {timeout} seconds")

    def setUp(self):
        # Connect to node
        self.w3 = Web3(Web3.HTTPProvider('http://0.0.0.0:8545'))
        assert self.w3.isConnected()

        # Deploy and initialize USDC on ETH
        self.eth_usdc = self.deploy_contract_from_source('lib/centre-tokens.git/contracts/v2/FiatTokenV2_1.sol', 'FiatTokenV2_1', '0.6.12')
        self.send_transaction(self.eth_usdc.functions.initialize(
            "USDC",
            "USDC",
            "USDC",
            0,
            addresses["eth_usdc_master_minter"],
            self.w3.eth.account.create().address,
            self.w3.eth.account.create().address,
            addresses["eth_usdc_master_minter"]
        ), "eth_usdc_master_minter")
        self.send_transaction(self.eth_usdc.functions.initializeV2("USDC"), "eth_usdc_master_minter")
        self.send_transaction(self.eth_usdc.functions.initializeV2_1(Web3.toChecksumAddress("0xb794f5ea0ba39494ce839613fffba74279579268")), "eth_usdc_master_minter")

        # Deploy and initialize USDC on AVAX
        self.avax_usdc = self.deploy_contract_from_source('lib/centre-tokens.git/contracts/v2/FiatTokenV2_1.sol', 'FiatTokenV2_1', '0.6.12')
        self.send_transaction(self.avax_usdc.functions.initialize(
            "USDC",
            "USDC",
            "USDC",
            0,
            addresses["avax_usdc_master_minter"],
            self.w3.eth.account.create().address,
            self.w3.eth.account.create().address,
            addresses["avax_usdc_master_minter"]
        ), "avax_usdc_master_minter")
        self.send_transaction(self.avax_usdc.functions.initializeV2("USDC"), "avax_usdc_master_minter")
        self.send_transaction(self.avax_usdc.functions.initializeV2_1(Web3.toChecksumAddress("0xb794f5ea0ba39494ce839613fffba74279579268")), "avax_usdc_master_minter")

        # Deploy and construct required token messenger contracts for ETH
        self.eth_message = self.deploy_contract_from_source('src/messages/Message.sol', 'Message')
        self.eth_message_transmitter = self.deploy_contract_from_source('src/MessageTransmitter.sol', 'MessageTransmitter', 
            libraries={'src/messages/Message.sol:Message': self.eth_message.address}, 
            constructor_args = [eth_domain, addresses["attester"], max_message_body_size, version], caller="eth_message_transmitter_deployer")
        self.eth_burn_message = self.deploy_contract_from_source('src/messages/BurnMessage.sol', 'BurnMessage')
        self.eth_token_messenger = self.deploy_contract_from_source('src/TokenMessenger.sol', 'TokenMessenger', 
            libraries={'src/messages/Message.sol:Message': self.eth_message.address, 'src/messages/BurnMessage.sol:BurnMessage': self.eth_burn_message.address}, 
            constructor_args=[self.eth_message_transmitter.address, message_body_version], caller="eth_token_messenger_deployer")
        self.eth_token_minter = self.deploy_contract_from_source('src/TokenMinter.sol', 'TokenMinter', 
            constructor_args = [addresses["eth_token_controller"]], caller="eth_token_minter_deployer")

        # Deploy and construct required token messenger contracts for AVAX
        self.avax_message = self.deploy_contract_from_source('src/messages/Message.sol', 'Message')
        self.avax_message_transmitter = self.deploy_contract_from_source('src/MessageTransmitter.sol', 'MessageTransmitter', 
            libraries={'src/messages/Message.sol:Message': self.avax_message.address}, 
            constructor_args = [avax_domain, addresses["attester"], max_message_body_size, version], caller="avax_message_transmitter_deployer")
        self.avax_burnMessage = self.deploy_contract_from_source('src/messages/BurnMessage.sol', 'BurnMessage')
        self.avax_token_messenger = self.deploy_contract_from_source('src/TokenMessenger.sol', 'TokenMessenger', 
            libraries={'src/messages/Message.sol:Message': self.avax_message.address, 'src/messages/BurnMessage.sol:BurnMessage': self.avax_burnMessage.address}, 
            constructor_args = [self.avax_message_transmitter.address, message_body_version], caller="avax_token_messenger_deployer")
        self.avax_token_minter = self.deploy_contract_from_source('src/TokenMinter.sol', 'TokenMinter', 
            constructor_args = [addresses["avax_token_controller"]], caller="avax_token_minter_deployer")

        # configureMinter to add minters
        self.send_transaction(self.eth_usdc.functions.configureMinter(addresses["eth_usdc_master_minter"], minter_allowance), "eth_usdc_master_minter")
        self.send_transaction(self.avax_usdc.functions.configureMinter(addresses["avax_usdc_master_minter"], minter_allowance), "avax_usdc_master_minter")
        self.send_transaction(self.eth_usdc.functions.configureMinter(self.eth_token_minter.address, minter_allowance), "eth_usdc_master_minter")
        self.send_transaction(self.avax_usdc.functions.configureMinter(self.avax_token_minter.address, minter_allowance), "avax_usdc_master_minter")

        # addLocalMinter to token messenger contracts
        self.send_transaction(self.eth_token_messenger.functions.addLocalMinter(self.eth_token_minter.address), "eth_token_messenger_deployer")
        self.send_transaction(self.avax_token_messenger.functions.addLocalMinter(self.avax_token_minter.address), "avax_token_messenger_deployer")

        # addLocalTokenMessenger to minter contracts
        self.send_transaction(self.eth_token_minter.functions.addLocalTokenMessenger(self.eth_token_messenger.address), "eth_token_minter_deployer")
        self.send_transaction(self.avax_token_minter.functions.addLocalTokenMessenger(self.avax_token_messenger.address), "avax_token_minter_deployer")

        # setMaxBurnAmountPerMessage to token messenger contracts
        self.send_transaction(self.eth_token_minter.functions.setMaxBurnAmountPerMessage(self.eth_usdc.address, max_burn_message_amount), "eth_token_controller")
        self.send_transaction(self.avax_token_minter.functions.setMaxBurnAmountPerMessage(self.avax_usdc.address, max_burn_message_amount), "avax_token_controller")

        # linkTokenPair
        self.send_transaction(self.eth_token_minter.functions.linkTokenPair(self.eth_usdc.address, avax_domain, self.to_32byte_hex(self.avax_usdc.address)), "eth_token_controller")
        self.send_transaction(self.avax_token_minter.functions.linkTokenPair(self.avax_usdc.address, eth_domain, self.to_32byte_hex(self.eth_usdc.address)), "avax_token_controller")

        # addRemoteTokenMessenger
        self.send_transaction(self.eth_token_messenger.functions.addRemoteTokenMessenger(avax_domain, self.to_32byte_hex(self.avax_token_messenger.address)), "eth_token_messenger_deployer")
        self.send_transaction(self.avax_token_messenger.functions.addRemoteTokenMessenger(eth_domain, self.to_32byte_hex(self.eth_token_messenger.address)), "avax_token_messenger_deployer")

    def test_crosschain_transfer(self):
        # Allocate 100 USDC each to avax_token_messenger_user and eth_token_messenger_user
        self.send_transaction(self.avax_usdc.functions.mint(addresses["avax_token_messenger_user"], mint_amount), "avax_usdc_master_minter")
        self.send_transaction(self.eth_usdc.functions.mint(addresses["eth_token_messenger_user"], mint_amount), "eth_usdc_master_minter")
        self.verify_balances(100, 100)

        # Approve USDC transfer from avax_token_messenger_user to avax_token_messenger
        self.send_transaction(self.avax_usdc.functions.approve(self.avax_token_messenger.address, mint_amount), "avax_token_messenger_user")

        # depositForBurn from avax_token_messenger_user to avax_token_messenger
        self.send_transaction(self.avax_token_messenger.functions.depositForBurn(mint_amount, eth_domain, self.to_32byte_hex(addresses["eth_token_messenger_user"]), self.avax_usdc.address), "avax_token_messenger_user")
        self.verify_balances(100, 0)

        # parse MessageSent event emitted by avax_message_transmitter
        avax_message_sent_filter = self.avax_message_transmitter.events.MessageSent.createFilter(fromBlock="0x0")
        avax_message_bytes = avax_message_sent_filter.get_new_entries()[0]['args']['message']
        avax_signed_message_bytes = self.w3.eth.account.signHash(Web3.keccak(avax_message_bytes), keys["attester"]).signature

        # receiveMessage with eth_message_transmitter to eth_token_messenger_user
        self.send_transaction(self.eth_message_transmitter.functions.receiveMessage(avax_message_bytes, avax_signed_message_bytes), "eth_token_messenger_user")
        self.verify_balances(200, 0)
    
        # Approve USDC transfer from eth_token_messenger_user to eth_token_messenger
        self.send_transaction(self.eth_usdc.functions.approve(self.eth_token_messenger.address, mint_amount), "eth_token_messenger_user")

        # depositForBurn from eth_token_messenger_user to eth_token_messenger
        self.send_transaction(self.eth_token_messenger.functions.depositForBurn(mint_amount, avax_domain, self.to_32byte_hex(addresses["avax_token_messenger_user"]), self.eth_usdc.address), "eth_token_messenger_user")
        self.verify_balances(100, 0)

        # parse MessageSent event emitted by eth_message_transmitter
        eth_message_sent_filter = self.eth_message_transmitter.events.MessageSent.createFilter(fromBlock="0x0")
        eth_message_bytes = eth_message_sent_filter.get_new_entries()[0]['args']['message']
        eth_signed_message_bytes = self.w3.eth.account.signHash(Web3.keccak(eth_message_bytes), keys["attester"]).signature

        # receiveMessage with avax_message_transmitter to avax_token_messenger_user
        self.send_transaction(self.avax_message_transmitter.functions.receiveMessage(eth_message_bytes, eth_signed_message_bytes), "avax_token_messenger_user")
        self.verify_balances(100, 100)

if __name__ == '__main__':
    unittest.main()
